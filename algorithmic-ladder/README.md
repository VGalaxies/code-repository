# 萌新 の 算法天梯题解



## 1. 选举班长

### 双向循环链表 97

启发于 malloc lab，不使用任何**复合数据结构**，直接操控内存

同时考虑了可移植性，使用 uint32_t 和 size_t 作为类型

结构如下：

```
┌─────────────┬─────────────────┬───────────────────┐
│    VALUE    │    PREV_ADDR    │     NEXT_ADDR     │
└─────────────┴─────────────────┴───────────────────┘
```

- VALUE → 4 bytes
- ADDR → 4 / 8 bytes



### 树状数组 + 二分 100

#### 基础

首先研究一下树状数组：

- 单点修改
- 区间和

时间复杂度均为：
$$
\mathcal{O} (logn)
$$
树状数组 a 建立了与原数组 b 的一一对应关系，若原数组为：

```
1 1 1 1 1 1 1 1 1 1 
```

则对应的树状数组为：

```
1 2 1 4 1 2 1 8 1 2 
```

$$
a[i] = sum \{b[i-lowbit(i)] \cdots b[i]\}
$$

> 下标从 1 开始计算，区间为左开右闭

其中

```c
int lowbit(int x) { return x & (-x); }
```

如 lowbit(0101) = 0001，lowbit(0110) = 0010

当我们想要**修改**原数组时，比如 `updata(3, 1)` 让 b[3] 加上 1

```c
void updata(int i, int k) {
  while (i <= n) {
    a[i] += k;
    i += lowbit(i);
  }
}
```

当我们想要求原数组的**前缀和**时，比如 `getsum(3) = b[1] + b[2] + b[3]` 

```c
int getsum(int i) {
  int res = 0;
  while (i > 0) {
    res += a[i];
    i -= lowbit(i);
  }
  return res;
}
```

由此，原数组的**区间和**也就容易求得了

我们还需要一个求 **kth** 的操作，这里使用了**二分**：

```c
int getid(int x) {
  if (x == 0)
    x = now;
  int l = 0, r = n, m;
  while (l + 1 < r) {
    m = (l + r) >> 1;
    if (getsum(m) >= x)
      r = m;
    else
      l = m;
  }
  return r;
}
```

若 `y = getid(x)`，则 `y` 是**最小**的使 `getsum(y) >= x` 成立的数

#### 主要思路

通过修改原数组，使得 `getid` 时跳过了那些已被清点过的同学

而 `getid` 的最小性保证了不会重复清点同学

关键在于 know 和 mnow 的更新

#### 关键例程

```c
int main() {
  scanf("%d%d%d", &n, &k, &m);
    
  now = n;
  for (int i = 1; i <= n; i++)
    updata(i, 1);
  
  // print();

  int know = 0, mnow = n;

  // iterate
  while (now) {
    int ktmp = (getsum(know) + (k % now)) % now;
    int mtmp = (getsum(mnow) + now + 1 - (m % now)) % now;

    know = getid(ktmp);
    mnow = getid(mtmp);

    Log("know = getid(%d), mnow = getid(%d)", ktmp, mtmp);

    if (know == mnow) {
      Log("%d", know);
      return 0;
    }

    Log("%d %d", know, mnow);
    now -= 2;

    updata(know, -1);
    updata(mnow, -1);

    // print();
  }

  return 0;
}
```

以输入 `10 4 3` 为例，初始时原数组均为 1，前缀和相当于对应的编号：

```
1 2 1 4 1 2 1 8 1 2 
1 1 1 1 1 1 1 1 1 1 
```

先看第一次选举，know 为 4，mnow 为 8

我们让 b[4] 和 b[8] 从 1 变为 0 后，可以观察到树状数组的 a[4] 减少了 1，a[8] 减少了 2

```
[main.c, 72, main] know = getid(4), mnow = getid(8)
[main.c, 77, main] 4 8
1 2 1 3 1 2 1 6 1 2 
1 1 1 0 1 1 1 0 1 1 
```

第二次选举，树状数组和原数组变化如下

```
[main.c, 72, main] know = getid(7), mnow = getid(4)
[main.c, 77, main] 9 5
1 2 1 3 0 1 1 5 0 1 
1 1 1 0 0 1 1 0 0 1 
```

第三次选举

```
[main.c, 72, main] know = getid(3), mnow = getid(1)
[main.c, 77, main] 3 1
0 1 0 1 0 1 1 3 0 1 
0 1 0 0 0 1 1 0 0 1 
```

第四次选举

```
[main.c, 72, main] know = getid(1), mnow = getid(2)
[main.c, 77, main] 2 6
0 0 0 0 0 0 1 1 0 1 
0 0 0 0 0 0 1 0 0 1 
```

第五次选举选出班长为 10 号同学

```
[main.c, 74, main] know = getid(0), mnow = getid(0)
[main.c, 77, main] 10
```

#### 时间复杂度分析

$$
\mathcal{O} (n(logn)^{2})
$$





## 23. 数字游戏

结果的形式为：
$$
\sum_{i} (-1)^{0 \ or \ 1}a_{i}
$$

### 结论

当全同号时，结果为：
$$
\sum_{i} |a_{i}| - 2 * \min_{i}(|a_{i}|)
$$
否则为：
$$
\sum_{i} |a_{i}|
$$

### 证明

- 非全同号时：

理论最大值即为上述结果，只要证明能够取到即可，使用归纳法：

1. 当只有两个数时，显然能够取到
2. 当多于两个数时，由于必定存在**正负边界**，只要适当的进行相减，就可以保证（因为可正可负）操作后的数仍然是非全同号，应用归纳假设即证

- 当全同号时：

1. 首先证明无法取到理论最大值，不妨均为正数，无论如何运算，最后的结果中总存在**相异符号**，可以使用归纳法说明
2. 上述结果为理论次大值，只要证明能够取到即可，通过将绝对值最小的数和周围的数相减，产生非全同号的情形即可



## 3. 小蓝鲸的散步

如果从出发点遍历二叉树并返回出发点，总路程为
$$
2n -2
$$
现在我们可以不必返回出发点，也就是少走了一段路，而这段路的长度一定 ≤ **树的直径**

所以问题化归为求树的直径，有两种方法



### 两次 DFS

我们有这样的结论，**从任意一点出发进行 DFS，能够达到的最远的点一定是直径的一端**

> 证明见 OI Wiki

于是只要进行两次 DFS 即可

> 注：两次 DFS 的方法要求树中不存在负权边，而本题所有路径的的长度均为 1，所以可以这样做



### 树形 DP

我们记录以每个点为根的子树延伸向下的**最远距离**和**次远距离**

由于是二叉树，所以简单的分类讨论即可

相较于 DFS 的做法，DP 的做法递归在前，相当于自底向上求解





## 6. 筒子的漫画

二分答案，套模板即可

最大值最小化（右侧合法的最小值）

```
  while (l <= r) {
    mid = (l + r) / 2;
    if (!check(mid)) { // 不满足条件
      l = mid + 1;
      ans = l;
    } else {
      r = mid - 1;
      ans = l;
    }
  }
```

注：

- check(mid) 全为 true，循环结束后 ans 为 `r + 1`
- check(mid) 全为 false，循环结束后 ans 为 `l`





## 24. 排列数数

朴素的想法是根据每一个排列计算其逆序数，但时间复杂度为
$$
\mathcal{O}(n \cdot log(n) \cdot n!)
$$
显然不可行

于是考虑动态规划的思路

设计状态
$$
f(i, j)
$$
表示在 `1 ~ i` 的所有全排列中，逆序对数量为 `j` 的有多少个

从小到大将数一个一个放入序列

注意到**放入数之后，当前放进去的那个数后面的数的个数成为序列逆序对数的增量**

于是有状态转移
$$
f(i,j) = \sum_{0 \le k \le i - 1} f(i-1,j-k)
$$
理论上时间复杂度为
$$
\mathcal{O}(n^{3})
$$
通过树状数组优化计算区间和，可优化为
$$
\mathcal{O}(n^{2}\cdot log(n))
$$
然而 OJ 会超时

发现没有必要使用树状数组，因为没有 update 操作

直接维护 sum 数组可以优化为
$$
\mathcal{O}(n^{2})
$$


## 17. 周游世界

注意从第 i 个城市到第 j 个城市的通行费为
$$
(i+j) mod (n+1)
$$
所以城市 1 和城市 n ，城市 2 和城市 n - 1，以此类推，之间的通行费为 0

再考虑城市 2 和城市 n，城市 3 和城市 n - 1，以此类推，之间的通行费为 1

这样就连通了，费用为
$$
\lfloor \frac{n-1}{2} \rfloor
$$


## 7. 家园树

首先根据题目要求建树，然后得到中序遍历序列 a

现在需要将这个序列变换为严格上升的序列 b



下面的操作比较秀，考虑序列 c，有
$$
c[i] = a[i] - i
$$
然后问题就化归为将 c 变换为不下降的序列

只要求出序列 c 的**最长不下降子序列**的长，就可以得到最少的修改次数

> 可以使用反证法，修改次数少了，一定存在下降的地方
>
> 子序列就是不需要修改的地方

比如

```
a:
1 3 2 4
c:
0 1 -1 0
```

最长不下降子序列的长为 2，最少的修改次数为 2

再如

```
a:
1 9 7 10
c:
0 7 4 6
```

最长不下降子序列的长为 3，最少的修改次数为 1

这里的思路是通过对每个 a[i] 减去不同的权值，使其变换为 c 后，去掉了上升的严格性

对于严格上升而言，因为数据是离散的，所以可能出现即使严格上升，也无法修改的情形

比如 a 为 `1 3 2 4`，**最长上升子序列**的长为 3，但是这里的 3 却无法修改



然后问题就化归为求**最长不下降子序列**的长

在代码中有两种做法，常规做法的复杂度为
$$
\mathcal{O}(n^{2})
$$
即朴素的动态规划，其中 dp[i] 表示**以下标 i 结尾**的子序列中最长不下降子序列的长

另一种做法是 `二分 + 贪心`，复杂度为
$$
\mathcal{O}(n\cdot log(n))
$$
dp 数组记录了可能的最长不下降子序列

下面是一个例子，给出了 `3 8 4 6 5 7` 对应的 dp 数组的变化

```
□ □ □ □ □ □
3 □ □ □ □ □
3 8 □ □ □ □
3 4 □ □ □ □
3 4 6 □ □ □
3 4 5 □ □ □
3 4 5 7 □ □
```



## 8. 旅行

状态压缩 DP

使用 `dp[i][s]` 记录，其中 i 代表最后停留的城市编号（下标减一），而 s 解释为一个二进制数
$$
s_{n-1}s_{n-2} \cdots s_{2}s_{1}s_{0}
$$
代表已经游览过的城市

状态转移方程如下

```c
  dp[0][1] = 0;
  for (int s = 1; s < (1 << n); ++s) {
    for (int i = 0; i < n; ++i) {
      if (GET(s, i) && dp[i][s] != LONG_LONG_MAX) {
        for (int j = 0; j < n; ++j) {
          if (!GET(s, j) && weight[i][j] != LONG_LONG_MAX) {
            if (dp[j][s | (1 << j)] > dp[i][s] + weight[i][j]) {
              dp[j][s | (1 << j)] = dp[i][s] + weight[i][j];
            }
          }
        }
      }
    }
  }
```

这里的关键是对于状态的枚举放在最外层循环

思路就是这样，不过对于数值较大的情形似乎会出错，不管了

时间复杂度为
$$
\mathcal{O}(2^{n} \cdot n^{2})
$$


## 21. 缆车观光

又是动态规划

由于路线要呈 Z 型，并且相同高度缆车站点只有一个

我们根据高度将缆车站点排序

设计状态

- to_left 代表 **↙** 到达目前站点之前的最大愉悦值，那么前一站必须为 to_right
- to_right 代表 **↘** 到达目前站点之前的最大愉悦值，那么前一站必须为 to_left

状态转移

```c++
  to_left[0] = cable[0].val;
  to_right[0] = cable[0].val;

  for (int i = 1; i < n; ++i) {
    for (int j = 0; j < i; ++j) {
      if (cable[j].x > cable[i].x) {
        to_left[i] = std::max(to_left[i], to_right[j] + cable[i].val);
      }
    }
    for (int j = 0; j < i; ++j) {
      if (cable[j].x < cable[i].x) {
        to_right[i] = std::max(to_right[i], to_left[j] + cable[i].val);
      }
    }
  }
```

时间复杂度为
$$
\mathcal{O}(n^{2})
$$
发现需要单点修改和求区间最值

> 区间似乎不连续
>
> 需要另外维护根据横坐标排序的缆车站点

使用线段树或树状数组即可优化为
$$
\mathcal{O}(n \cdot log(n))
$$


## 22. 桥梁连通

还是动态规划

要求任意两个**相同颜色**的岛屿要么不相通，要么这两座岛屿之间的最短路大于等于 3

注意到正好有三种颜色的岛屿

于是约束条件化归为**对于任意两种颜色的岛屿集之间，每个岛屿最多连出一条边**

注意到这个条件对于考虑不同的两种颜色岛屿集之间是**独立**的

> 充分性和必要性两个方向证明

下面设计状态，考虑
$$
f(i,j)
$$
为两种颜色的岛屿集，岛屿数量分别为 i 和 j 的方案数

有状态转移
$$
f(i,j)=f(i-1,j)+j \cdot f(i-1,j-1)
$$
解释为

- 一个岛屿集的某个岛屿和另一个岛屿集没有连边
- 一个岛屿集的某个岛屿和另一个岛屿的任意一个岛屿有连边

最后的结果即为
$$
f(a,b) \cdot f(b,c) \cdot f(c,a)
$$
时间复杂度为
$$
\mathcal{O}(n^{2})
$$
代码略



## 10. 守护鸽

暴力搜索只能得 60 分

```
long long search(int x, int y, int another, int time, int flag);
```

先解释一下各个参数的含义

- x 和 y 为当前坐标
- another 代表另一排林地还未消灭的起始横坐标
- time 代表当前时间
- flag 代表以什么方向进入当前坐标

来参考一下官方题解，求最大值

https://codeforces.com/blog/entry/61015

看不懂

参考一下标程

也看不懂



## 15. 随机游走

https://oj.seucpc.club/problem/106

不会算概率……

大概可以列一个巨大的多元一次方程组



## 11. 数数列

考虑在
$$
[l,r]
$$
这个区间中，模 3 余 0/1/2 的数的个数为 a/b/c

设计状态
$$
f(n,0/1/2)
$$
表示前 n 个数的和模 3 余 0/1/2 的数列个数

有状态转移
$$
f(n,0)= a \cdot f(n-1,0) + c \cdot f(n-1,1) + b \cdot f(n-1,2)
$$
同理还有两个式子

写成矩阵形式为
$$
[f(n,0),f(n,1),f(n,2)] = [f(n-1,0),f(n-1,1),f(n-1,2)] \cdot \begin{bmatrix} a & b & c \\ c & a & b \\ b & c & a \end{bmatrix}
$$
使用**矩阵快速幂**，可优化时间复杂度为
$$
\mathcal{O}(log(n))
$$
